# train_gpt_mini_1_5_turbo_multilingual_final.py
import torch
import torch.nn as nn
from torch.utils.data import DataLoader
from datasets import load_dataset, concatenate_datasets
from transformers import PreTrainedModel, PretrainedConfig
import os
import json
from PIL import Image
import open_clip
import whisper
from dalle_pytorch import DALLE
import sentencepiece as spm

# ==== Tokenizer multil√≠ngue com SentencePiece ====
class MultilingualTokenizer:
    def __init__(self, model_file="spm.model"):
        if not os.path.exists(model_file):
            # Cria modelo SentencePiece com vocabul√°rio de 32k tokens
            print("üõ†Ô∏è Criando tokenizer multil√≠ngue...")
            spm.SentencePieceTrainer.Train(
                input="all_texts.txt", model_prefix="spm", vocab_size=32000,
                character_coverage=1.0, model_type="bpe"
            )
        self.sp = spm.SentencePieceProcessor(model_file=model_file)

    def encode(self, text):
        return self.sp.encode(text, out_type=int)

    def decode(self, ids):
        return self.sp.decode(ids)

    @property
    def vocab_size(self):
        return self.sp.get_piece_size()

# ==== Transformer Block ====
class TransformerBlock(nn.Module):
    def __init__(self, embed_size, heads, ff_hidden):
        super().__init__()
        self.attn = nn.MultiheadAttention(embed_dim=embed_size, num_heads=heads, batch_first=True)
        self.norm1 = nn.LayerNorm(embed_size)
        self.ff = nn.Sequential(
            nn.Linear(embed_size, ff_hidden),
            nn.ReLU(),
            nn.Linear(ff_hidden, embed_size)
        )
        self.norm2 = nn.LayerNorm(embed_size)

    def forward(self, x):
        attn_out, _ = self.attn(x, x, x)
        x = self.norm1(x + attn_out)
        x = self.norm2(x + self.ff(x))
        return x

# ==== GPT-Mini Config ====
class GPTMiniConfig(PretrainedConfig):
    model_type = "gpt-mini"
    def __init__(self, vocab_size=32000, n_embd=512, n_layer=6, n_head=8, max_len=128, **kwargs):
        super().__init__(**kwargs)
        self.vocab_size = vocab_size
        self.n_embd = n_embd
        self.n_layer = n_layer
        self.n_head = n_head
        self.max_len = max_len

# ==== GPT-Mini Modelo ====
class GPTMiniForCausalLM(PreTrainedModel):
    config_class = GPTMiniConfig

    def __init__(self, config):
        super().__init__(config)
        self.token_emb = nn.Embedding(config.vocab_size, config.n_embd)
        self.pos_emb = nn.Embedding(config.max_len, config.n_embd)
        self.layers = nn.ModuleList([TransformerBlock(config.n_embd, config.n_head, config.n_embd*4)
                                     for _ in range(config.n_layer)])
        self.ln_f = nn.LayerNorm(config.n_embd)
        self.head = nn.Linear(config.n_embd, config.vocab_size)

        # ==== Multimodalidade ====
        self.clip_model, _, self.clip_preprocess = open_clip.create_model_and_transforms('ViT-B-32', pretrained='laion2b_s32b_b82k')
        self.whisper_model = whisper.load_model("base")
        self.dalle_model = DALLE.load_model('path_to_dalle_model')  # ajustar path

    def forward(self, input_ids, image=None, audio=None):
        B, T = input_ids.shape
        pos = torch.arange(T, device=input_ids.device).unsqueeze(0)
        x = self.token_emb(input_ids) + self.pos_emb(pos)
        for layer in self.layers:
            x = layer(x)
        x = self.ln_f(x)

        if image:
            image_features = self.process_image(image)
            # Exemplo: x = x + image_features.unsqueeze(1)

        if audio:
            audio_text = self.transcribe_audio(audio)
            # Pode concatenar embeddings de √°udio ao texto

        return self.head(x)

    def process_image(self, image_path):
        image = Image.open(image_path).convert('RGB')
        image_tensor = self.clip_preprocess(image).unsqueeze(0)
        with torch.no_grad():
            features = self.clip_model.encode_image(image_tensor)
        return features

    def transcribe_audio(self, audio_path):
        result = self.whisper_model.transcribe(audio_path)
        return result['text']

    def generate_image(self, text_prompt):
        image_tensor = self.dalle_model.generate_images(text_prompt)
        image = Image.fromarray(image_tensor.numpy())
        return image

# ==== Carrega datasets multil√≠ngue ====
def load_multilingual_dataset(tokenizer, max_len=128):
    wiki_pt = load_dataset("wikipedia","20220301.pt", split="train")
    wiki_en = load_dataset("wikipedia","20220301.en", split="train")
    wiki_fr = load_dataset("wikipedia","20220301.fr", split="train")
    wiki_es = load_dataset("wikipedia","20220301.es", split="train")

    oscar_pt = load_dataset("oscar","unshuffled_deduplicated_pt", split="train")
    oscar_multi = load_dataset("oscar","unshuffled_deduplicated_multi", split="train")

    qa_pt = load_dataset("cais/mmlu-pt", split="train")
    code = load_dataset("bigcode/the-stack-dedup", data_dir="data/python", split="train")

    datasets = [wiki_pt, wiki_en, wiki_fr, wiki_es, oscar_pt, oscar_multi, qa_pt, code]

    def tokenize_fn(examples):
        text_col = "text" if "text" in examples else list(examples.keys())[0]
        texts = examples[text_col]
        input_ids = [tokenizer.encode(t)[:max_len] for t in texts]
        return {"input_ids": input_ids}

    tokenized = [d.map(tokenize_fn, batched=True, remove_columns=d.column_names) for d in datasets]
    dataset = concatenate_datasets(tokenized)
    return dataset

# ==== Treino ====
def train():
    device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
    tokenizer = MultilingualTokenizer()
    dataset = load_multilingual_dataset(tokenizer)
    dataloader = DataLoader(dataset, batch_size=8, shuffle=True)

    config = GPTMiniConfig(vocab_size=tokenizer.vocab_size)
    model = GPTMiniForCausalLM(config).to(device)

    optimizer = torch.optim.AdamW(model.parameters(), lr=3e-4)
    criterion = nn.CrossEntropyLoss()

    for epoch in range(5):
        total_loss = 0
        for batch in dataloader:
            input_ids = torch.tensor(batch["input_ids"], dtype=torch.long).to(device)
            labels = input_ids.clone()

            outputs = model(input_ids)
            logits = outputs.view(-1, tokenizer.vocab_size)
            loss = criterion(logits, labels.view(-1))

            optimizer.zero_grad()
            loss.backward()
            optimizer.step()
            total_loss += loss.item()

        print(f"üìò Epoch {epoch+1} - Avg Loss: {total_loss/len(dataloader):.4f}")

    save_dir = "./GPT-Mini-1.5-Turbo-Multilingual"
    os.makedirs(save_dir, exist_ok=True)
    model.save_pretrained(save_dir)
    print("‚úÖ Modelo treinado e salvo com multimodalidade!")

if __name__ == "__main__":
    train()
